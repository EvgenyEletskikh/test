# Реализация алгоритма CORDIC для вычисления экспоненты через функции гиперболического косинуса и синуса

## Оглавление
1. Краткое описание алгоритма
2. Реализация алгоритма в Matlab R2018b
3. Реализация алгоритма в Vivado 2019.1
    - Описание блоков
        + cordic_unit
        + cordic_top
        + tb
    - Результат работы алгоритма
4. Заключение









## Краткое описание алгоритма

Реализованный мной алгоритм CORDIC работает в режиме расчета гиперболических функций методом вращения.

В этом режиме блок имеет следующую сходимость:

![Рисунок блока CORDIC из презентации][fig_cordic_block_presentation]

Формулы для вычисления _i_-тых значений для _x, y, z_ имеют следующий вид:
 
![equation](https://latex.codecogs.com/svg.image?x_{i}&space;=&space;x_{i-1}&space;&plus;&space;d_{i}&space;*&space;y_{i-1}&space;*&space;2^{-i})

![equation](https://latex.codecogs.com/svg.image?y_{i}&space;=&space;y_{i-1}&space;&plus;&space;d_{i}&space;*&space;x_{i-1}&space;*&space;2^{-i})

![equation](https://latex.codecogs.com/svg.image?z_{i}&space;=&space;z_{i-1}&space;-&space;d_{i}&space;*&space;tanh^{-1}&space;(2^{-i}))

где ![equation](https://latex.codecogs.com/svg.image?d_{i}&space;=&space;sign(z_{i-1}))

Тогда

![equation](https://latex.codecogs.com/svg.image?x_{n}&space;=&space;A_{n}[x_{0}&space;cosh&space;(z_{0})&space;&plus;&space;y_{0}&space;sinh&space;(z_{0})])

![equation](https://latex.codecogs.com/svg.image?y_{n}&space;=&space;A_{n}[y_{0}&space;cosh&space;(z_{0})&space;&plus;&space;x_{0}&space;sinh&space;(z_{0}]))

![equation](https://latex.codecogs.com/svg.image?z_{n}&space;=&space;0)

где ![equation](https://latex.codecogs.com/svg.image?A_{n}&space;=$&space;$\prod_{n}$&space;$\sqrt{1&space;-&space;2^{-2i}}) - масштабирующий коэффициент.

В этом режиме мы можем рассчитать не только значения гиперболического косинуса и синуса, но и функцию экспоненты как 

![equation](https://latex.codecogs.com/svg.image?e^{z}&space;=&space;sinh(z)&space;&plus;&space;cosh(z))


В данном режиме работы алгоритма важным является следующий момент: чтобы обеспечить сходимость получаемых результатов, расчет значений _k_-той итерации необходимо выполнять дважды для всех

![equation](https://latex.codecogs.com/svg.image?k&space;=&space;3i&plus;1,\space&space;i&space;\in&space;\mathbb{N})



![equation]()

![equation]()







## Реализация алгоритма в Matlab R2018b

Сперва было принято решение по реализации данного алгоритма в среде _Matlab_, что позволяет проверять корректность данных, получаемых на _Verilog_, а также встроенные средства _Matlab_ позволяют подготовить и быстро менять перечень входных данных для языка _Verilog_ в удобном виде.

Все функции, не являющиеся встроенными в _Matlab_, находятся в папке _**src/matlab/**_

Файл _**CordicHyper.m**_ является реализацией самого алгоритма CORDIC. На вход одноименной функции подаются значение аргумента и количество итераций.

<ссылка на файл cordicHyper>

Файл **_main.m_** является главным файлом, реализующим как вызов самого алгоритма, так и вывод различных данных таких как:

-	_PrintInitialValue()_ выводит текстовую информацию для блока Initial модуля tb в Verilog;
-	_PlotGraphics()_ строит графики сравнения функций, посчитанных алгоритмом, с идеальными;
-	_PrintLUTbinary()_ выводит в текстовом виде таблицу значений для ареатангенса;
-	_PrintResult()_ выводит в кратком текстовом виде результаты вычисления с помощью алгоритма указанной в скобках функции.

<ссылка на файл main>

В результате были получены графики, представленные на рисунке ниже:

![Сравнительные графики][fig_matlab]







## Реализация алгоритма в Vivado 2019.1

В _Vivado_ я реализовал проект с использованием языка _Verilog_ для знаковых 32-битных чисел с 16-битной дробной частью (_fixed point_). 

Проект состоит из трех модулей (в порядке иерархии): 
- tb
- cordic_top
- cordic_unit

### Описание блоков

#### **cordic_unit**
----

Модуль _**cordic_unit**_ является блоком, выполняющим расчеты промежуточных значений параметров, соответствующих определенной итерации. 

На вход блока подаются:
-	параметр _CURIT_, указывающий на порядковый номер итерации, которую осуществляет блок;
-	тактовый сигнал _CLK_;
-	входные данные каналов _x_, _y_ и _z_;
-	соответствующее текущей итерации значение ареатангенса из таблицы.

Выходом блока являются пересчитанные значения _x_, _y_ и _z_.

![RTL-представление модуля cordic_unit][scheme_unit_expanded2]

#### **cordic_top**
----

Модуль _**cordic_top**_ является управляющим модулем в реализации данного алгоритма.

На вход модуль принимает:
-	параметр _ITERS_ – общее количество итераций в алгоритме (не более 16);
-	параметр _SW_ – флаг, указывающий на функцию, рассчитываемую алгоритмом (1 – _sinh(z)_, 2 – _cosh(z)_, 3 – _exp(z)_);
-	тактовый сигнал _CLK_;
-	входные данные для алгоритма, соответствующие входным каналам _x_, _y_ и _z_.

Выходом модуля является результат работы алгоритма.

Внутри модуля генерируются _ITERS_ последовательно соединенных друг с другом проводами блоков _**cordic_unit**_, а также таблица значений ареатангенса _atanhLUT_. 

Такой подход позволяет реализовать конвейерную работу алгоритма, в результате чего на любые вычисления уходит всегда _ITERS_ итераций, но для расчета _N_ значений нам потребуется не _ITERS*N_ итераций, а _ITERS+N_.

![RTL-представление модуля cordic_top][scheme_top_expanded]

#### **tb**
----

Модуль _**tb**_ является тестбенчем для проверки работы алгоритма. Здесь в качестве тестируемого модуля выступает блок _**cordic_top**_, на вход которого подаются заранее сгенерированные мной значения _x_, _y_ и _z_. 
рисунок _scheme_top_


### Результат работы алгоритма

Чтобы выполнялся непосредственно поиск значений гиперболических синуса и косинуса, я на вход подавал на вход _x_ значение _1/К_, на вход _y_ – ноль, на вход _z_ – значение аргумента функции.

В результате работы алгоритма для входных аргументов, принадлежащих промежутку _**[-1; 1]**_ я получил значения, совпадающие с вычисленными в _Matlab_ с точностью до 2 знака после запятой.

Ниже представлены временные диаграммы работы алгоритма в режиме расчета экспоненты. Входные данные выделены голубым цветом, выходные – желтым.

![Временная диаграмма 1][time_1val]

![Временная диаграмма 2][time_severalval]







## Заключение

Основываясь на проведенных испытаниях, могу сделать вывод, что использование алгоритма CORDIC для расчета гиперболических функций целесообразно в том случае, когда у нас есть необходимость использовать только сумматоры, сдвиговые регистры, обычные регистры и мультиплексоры. В остальных случаях я бы не стал использовать данный алгоритм в силу его неточности и большой зависимости от количества итераций и разрядности входных данных. 

Алгоритм показал хорошую точность вычислений для аргументов, лежащих в промежутке _**[-1; 1]**_. Вне этого промежутка результаты начинают заметно расходиться с табличными. Также, исходя из графика, полученного в _Matlab_, можно сделать вывод, что гиперболический косинус начинает расходиться быстрее и сильнее, чем синус, но на _Verilog_ алгоритм продемонстрировал иные результаты – гиперболический косинус на заданном отрезке вычислялся с точностью до 3 знака после запятой во всех тестируемых точках, в то время как синус начинал расходиться с идеальными результатами вблизи нуля.

Полагаю, что для вычисления функций от аргументов вне описанного промежутка необходимо искать математические лазейки с масштабированием на заданный отрезок.








[fig_cordic_block_presentation]: /img/cordic_block_presentation.PNG "Рисунок CORDIC"
[fig_matlab]: /img/matlab_graphics.PNG "Сравнительные графики"
[scheme_unit_expanded2]: /img/scheme_unit_expanded2.PNG "RTL-представление модуля cordic_unit"
[scheme_top_expanded]: /img/scheme_top_expanded.PNG "RTL-представление модуля cordic_top"
[time_1val]: /img/time_1val.PNG "Временная диаграмма 1"
[time_severalval]: /img/time_severalval.PNG "Временная диаграмма 2"
