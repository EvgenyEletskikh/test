# Реализация алгоритма CORDIC для вычисления экспоненты через функции гиперболического косинуса и синуса

## Оглавление
1. Краткое описание алгоритма
2. Реализация алгоритма в Matlab R2018b
3. Реализация алгоритма в Vivado 2019.1
    - Описание блоков
        + cordic_unit
        + cordic_top
        + tb
    - Результат работы алгоритма
4. Заключение









## Краткое описание алгоритма

Реализованный мной алгоритм CORDIC работает в режиме расчета гиперболических функций методом вращения.

В этом режиме блок имеет следующую сходимость:

![Рисунок блока CORDIC из презентации][fig_cordic_block_presentation]

Формулы для вычисления _i_-тых значений для _x, y, z_ имеют следующий вид:

$x_{i} = x_{i-1} + d_{i} * y_{i-1} * 2^{-i}$

$y_{i} = y_{i-1} + d_{i} * x_{i-1} * 2^{-i}$

$z_{i} = z_{i-1} - d_{i} * tanh^{-1} (2^{-i})$

где $d_{i} = sign(z_{i-1})$

Тогда

$x_{n} = A_{n}[x_{0} cosh (z_{0}) + y_{0} sinh (z_{0})]$

$y_{n} = A_{n}[y_{0} cosh (z_{0}) + x_{0} sinh (z_{0}])$

$z_{n} = 0$

где $A_{n} =$ $\prod_{n}$ $\sqrt{1 - 2^{-2i}}$ - масштабирующий коэффициент.

В этом режиме мы можем рассчитать не только значения гиперболического косинуса и синуса, но и функцию экспоненты как 

$e^{z} = sinh(z) + cosh(z)$

В данном режиме работы алгоритма важным является следующий момент: чтобы обеспечить сходимость получаемых результатов, расчет значений _k_-той итерации необходимо выполнять дважды для всех
$k = 3i+1,\space i \in \mathbb{N}$.









## Реализация алгоритма в Matlab R2018b

Сперва было принято решение по реализации данного алгоритма в среде _Matlab_, что позволяет проверять корректность данных, получаемых на _Verilog_, а также встроенные средства _Matlab_ позволяют подготовить и быстро менять перечень входных данных для языка _Verilog_ в удобном виде.

Все функции, не являющиеся встроенными в _Matlab_, находятся в папке _**src/matlab/**_

Файл _**CordicHyper.m**_ является реализацией самого алгоритма CORDIC. На вход одноименной функции подаются значение аргумента и количество итераций.

<ссылка на файл cordicHyper>

Файл **_main.m_** является главным файлом, реализующим как вызов самого алгоритма, так и вывод различных данных таких как:

-	_PrintInitialValue()_ выводит текстовую информацию для блока Initial модуля tb в Verilog;
-	_PlotGraphics()_ строит графики сравнения функций, посчитанных алгоритмом, с идеальными;
-	_PrintLUTbinary()_ выводит в текстовом виде таблицу значений для ареатангенса;
-	_PrintResult()_ выводит в кратком текстовом виде результаты вычисления с помощью алгоритма указанной в скобках функции.

<ссылка на файл main>

В результате были получены графики, представленные на рисунке ниже:

![Сравнительные графики][fig_matlab]







## Реализация алгоритма в Vivado 2019.1

В _Vivado_ я реализовал проект с использованием языка _Verilog_ для знаковых 32-битных чисел с 16-битной дробной частью (_fixed point_). 

Проект состоит из трех модулей (в порядке иерархии): 
- tb
- cordic_top
- cordic_unit

### Описание блоков

#### **cordic_unit**

Модуль _**cordic_unit**_ является блоком, выполняющим расчеты промежуточных значений параметров, соответствующих определенной итерации. 

На вход блока подаются:
-	параметр _CURIT_, указывающий на порядковый номер итерации, которую осуществляет блок;
-	тактовый сигнал _CLK_;
-	входные данные каналов _x_, _y_ и _z_;
-	соответствующее текущей итерации значение ареатангенса из таблицы.

Выходом блока являются пересчитанные значения _x_, _y_ и _z_.

![RTL-представление модуля cordic_unit][scheme_unit_expanded2]

#### **cordic_top**

Модуль _**cordic_top**_ является управляющим модулем в реализации данного алгоритма.

На вход модуль принимает:
-	параметр _ITERS_ – общее количество итераций в алгоритме (не более 16);
-	параметр _SW_ – флаг, указывающий на функцию, рассчитываемую алгоритмом (1 – sinh(z), 2 – cosh(z), 3 – exp(z));
-	тактовый сигнал _CLK_;
-	входные данные для алгоритма, соответствующие входным каналам _x_, _y_ и _z_.

Выходом модуля является результат работы алгоритма.

Внутри модуля генерируются _ITERS_ последовательно соединенных друг с другом проводами блоков cordic_unit, а также таблица значений ареатангенса atanhLUT. 

Такой подход позволяет реализовать конвейерную работу алгоритма, в результате чего на любые вычисления уходит всегда _ITERS_ итераций, но для расчета _N_ значений нам потребуется не _ITERS*N_ итераций, а _ITERS+N_.


#### **tb**

### Результат работы алгоритма














## Заключение


[fig_cordic_block_presentation]: /img/cordic_block_presentation.PNG "Рисунок CORDIC"
[fig_matlab]: /img/matlab_graphics.PNG "Сравнительные графики"
[scheme_unit_expanded2]: /img/scheme_unit_expanded2.PNG "RTL-представление модуля cordic_unit"
